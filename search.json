[{"title":"C语言学习记录","url":"/2026/02/06/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","content":"本章是基于，《C Primer Plus 第六版》的框架来搭建的，我会在学习的过程中补充很多书中没有的东西或者是我自己理解的内容。\n如何学习C语言\n学习方法：\n多练习\n1.一定要多写代码，可以拿纸写，看了技术书籍或者课程之后一定要多多刷题，刷练习题、刷课后习题\n2.练习的目的是熟悉语法，语法熟悉了才能无障碍的写代码\n3.练习是在锻炼编程思维，就是把实际问题转换成代码的能力\n学会画图\n1.画图去理解内存，理解指针\n2.画图可以理清思路\n3.画图可以辅助理解，强化理解\n学会调试\n1.借助调试，可以让我们可以更好的理解和感知代码\n2.借助调试，可以让我们找出代码中的bug\n初识C语言\nC语言的起源\n选择C语言的理由\n设计特性\n高效性\n可移植性\n强大而且灵活\n面向程序员\n缺点\nC语言的应用范围\n计算机能做什么\n高级计算机语言和编译器\n语言标准\n第一个ANSI/ISO C标准\nC99标准\nC99标准之前，数组的大小都是用常量或者常量表达式来指定\nC99标准之后，支持了变长数组，这个时候允许数组的大小是变量，但是这种指定方式的数组是不能初始化的。\nC11标准\nC语言概述\n数据和C\n字符串和格式化输入输出\n运算符、表达式和语句\nC控制语句：循环\nC控制语句：分支和跳转\n字符输入/输出和输入验证\n函数\n数组和指针\n字符串和字符串数组\n存储类别、链接和内存管理\n文件输入/输出\n数据结构和其他数据形式\n位操作\nC预处理和C库\n高级数据表示\n","categories":["编程学习","C"]},{"title":"VScode调试教程","url":"/2026/02/04/vscode%E8%B0%83%E8%AF%95%E6%95%99%E7%A8%8B/","content":"大家好，我是Gin。Vscode的调试问题想必困扰了很多人，其实原理很简单，今天我就来做一个C语言调试的详细教程。希望看了我的教程之后可以帮助到大家。\nClang调试方法\nClang单文件调试\n下载CodeLLDB插件\n首先第一步，我们需要在Vscode的插件商店中去下载一个叫做CodeLLDB的插件。\n如下图所示\n\n写一个简单程序\n我们先写一个简单的程序\nmain.c\n#include &lt;stdio.h&gt;int main()&#123;    int num1 = 0;    int num2 = 0;    scanf(&quot;%d %d&quot;, &amp;num1, &amp;num2);    printf(&quot;--START--\\n&quot;);    printf(&quot;%d %d\\n&quot;, num1, num2);    printf(&quot;--END--\\n&quot;);    return 0;&#125;\n简单程序介绍\n好的，这是一个非常简单的C程序。这个程序中给定了两个变量，再通过 scanf() 读取数，随后在通过 printf() 打印出来。我添加了 printf(“–START–\\n”); 和 printf(“–END–\\n”); 是为了更直观的反应出输出程序的开始和结束。\n调试前准备工作\n接下来就可以开始我们的调试了\n\n首先我们先按一下右上角的按钮，点击调试C/C++文件\n随后便会出现让你选择调试配置的页面，我们选择 Clang 构建和调试活动文件 即可。\n\n之后就会出现 终端将被任务重用，按任意键关闭 ，没有关系我们这一步就是为了叫做 tasks.json 的文件，随后我们打开它。\n\n\n我们打开了这个tasks.json的文件之后就会看到这么一大串我们看不懂的东西。\n\n没有关系这个文件我们先备用着，接下来就是关键的部分了\n生成一个launch.json的文件\n我们点击最左边的这个按钮（我在下面的图片中有圈出来）\n\n点进去之后就可以看到生成一个launch.json的文件的选项，我们点击（我画线的部分）\n\n点击创建一个launch.json 文件之后上端就会出现选择调试器这个标识，选择我CodeLLDB（我圈出来的部分）\n\n点击CodeLLDB之后，千万千万不要选择 C/C++:(lldb)启动、C/C++:(lldb)附加这些东西千万不要。\n\n开始配置调试文件\nOK，现在我们的准备工作也算是做完了，接下来我们就要开始配置调试文件了\n我们先打开我们刚才生成好的tasks.json的文件,随后复制一下我标注出来的部分。\n\n复制完成之后我们再打开我们的launch.json文件，把我们刚才复制的内容粘贴到我做标记的部分。\n\n随后保存就可以，接下来我们还要再配置一项内容，配置完成这项内容之后我们每一次修改完源文件就不需要再重新点击调试按钮重新生成，而是直接点击运行就可以了。\n那么按我的方法接下去配置，首先打开launch.json文件，创建一个\npreLaunchTask (下图我标注出来的部分就是要创建这个条件的地方，注意：一定要加上双引号，在最后加上逗号)\n\n创建完preLaunchTask之后，再打开tasks.json文件，复制我所标记的部分\n\n复制完成之后我们在打开launch.json文件，随后把我刚才复制的那部分粘贴到我标记的部分。\n\n好了，这样子我们的调试文件就全部都配置完成了，接下来便可以开始调试运行我们的程序了。\n开始调试\n我们先别着急运行，可以先添加一些断点，下面图片中每一行代码前面的红色小点点就是断点（添加断点的方法非常简单：只需要点击一下每一行代码数字前面就可以了）随后我们点击Launch边上的开始按钮（我也画红线标注了）\n\n这样子，我们的程序就被调试运行起来了也是，我们可以在下面终端处输入数字，然后点击单步调试等就可以开始调试了（我圈出来了）\n\n好的，单文件的调试方法现在已经给大家讲完了，希望大家看到这里可以有一些收获。\nClang多文件调试\n讲完了单文件调试，我现在要给大家讲一讲多文件调试了\n写一个简单的程序\n和单文件一样，我们先写一个简单的程序\nadd.h\n#include &lt;stdio.h&gt;int add(int a, int b);\nmain.c\n#include &quot;add.h&quot;int main()&#123;    int a = 0;    int b = 0;    scanf(&quot;%d %d&quot;, &amp;a, &amp;b);    int ret = add(a, b);    printf(&quot;%d&quot;, ret);    return 0;&#125;\nadd.c\nint add(int a, int b)&#123;    int c = a + b;    return c;&#125;\n简单介绍一下程序\n好了，程序写完了，我先简单介绍一下这个程序吧。首先，在add.h这个文件里放的是这个程序的所有声明（包括主函数的声明也在里面）在main.c这个文件里面定义了两个变量a,b，随后通过scanf（）输入值传到add函数中去，在通过ret来接收add函数的返回值，然后打印出来。在add.c这个文件中接收a,b的值，随后算出a + b的值然后在返回a + b的和。\n多文件调试前的准备工作\n和单文件调试一样，我们先按一下右上角的按钮生成 tasks.json 的文件 切记切记，一定要在main.c这个主函数中去按 然后跟单文件调试一样，选择 Clang 就可以了。随后，程序就会发出一个报错，没有关系，我们这步只是为了生成 tasks.json 这个文件，我们点终止就可以了（我在下图全圈出来了）\n\n那么这样子我们目的达成 tasks.json 文件生成了，接下来我们和单文件的方法一样去创建一个 launch.json 的文件，（选择CodeLLDB）。同样去 tasks.json 中复制随后粘贴到 launch.json 中去，别忘了也创建一个 preLaunchTask\n由于是多文件调试，接下来就展示一下和单文件调试不一样的地方，我们还要在 tasks.json 文件中添加一下我们另外一个文件（例如：add.c）的名字，如下图所示。\n\n开始调试\n添加完成文件之后就可以开始调试了，和单文件一样。\n好了，现在VScode，Clang的调试教程到这里就全部都讲完了。\ngcc调试方法\n配置前准备工作\n下载homebrew\n我这里主要就是演示Mac系统的 gcc 下载方式。\n首先我们要去安装一下 homebrew 这个非常好用的软件安装工具，你想要用的很多工具比如：git、gcc、python3等等都可以用homebrew的指令进行安装。\n我们先去 homebrew 的官网下载，打开 https://brew.sh/ 随后后复制一下我画线的部分命令。\n\n把这串命令粘贴到终端，随后就按回车\n\n随后就可以看到让你输密码的选项，注意直接输入你的开机密码，你输入的密码终端上是不显示的。\n\n输完密码之后按回车就可以看到这样子的内容，按回车继续就可以了\n\n随后你就安装好 homebrew 了，但是先别着急我们还要让那homebrew被终端识别到\n输入以下命令：\necho &#x27;eval &quot;$(/opt/homebrew/bin/brew shellenv zsh)&quot;&#x27; &gt;&gt; ~/.zprofileeval &quot;$(/opt/homebrew/bin/brew shellenv zsh)&quot;\n验证homebrew是否安装\n我们只需要在终端中输入 brew --version 就可以了，输入完成之后如下图所示\n\n现在，homebrew的安装到这里就结束了\n下载gcc\n我们直接在终端输入 brew install gcc 就可以安装gcc了，安装完成后如下图所示\n\n验证gcc是否安装\n同样的我们只需要在终端中输入 gcc --version 如果输出与下图类似的内容就说明安装成功。\n\ngcc调试\n其实gcc的调试方法和clang的调试方法几乎一模一样，我们只需要改一下 launch.json 中的 “preLaunchTask” 这个选项后面的配置就可以了，下面我来介绍。\n生成一个tasks.json的文件\n和Clang调试一样，我们需要先生成一个 tasks.json 的文件。如下图所示，这回我们要在 选择调试配置 中选择gcc - 14 构建和调试活动文件就可以了。\n\n创建launch.json的文件\n接下来创建一个 launch.json 的文件，和clang调试的方法一样，这里就不做过多赘述。\n配置调试文件\n我们在 launch.json 文件中配置完成之后,注意 “preLaunchTask” 这一处需要改一下，如下图所示。\n\n好了这样子调试文件配置成了。\n开始调试\n调试无非就是加上断点，程序是怎么变化的，这里和clang的调试一样，我也就不做过多赘述。\n声明\n我在这里只是教大家一下调试的方法，并没有说明很多调试的技巧，这些技巧需要大家在学习的过程中去慢慢领悟，那么gcc、clang这两大主流编译器调试的方法到这里就给大家讲完了，感谢您的阅读。\n","categories":["教程","MacOS开发"],"tags":["MacOS开发","教程"]},{"title":"扫雷游戏","url":"/2026/02/07/%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F/","content":"游戏介绍\n大家好，我是Gin。今天我来给大家看一个好玩的C语言小游戏，主要是运用了 二维数组 、 循环 、 if else语句 等等来实现的，虽然这个游戏比较基础，比较简陋，但是还是可以玩的比较开心，扫雷的基本功能也还是在的，我是在看 B站鹏哥C语言 课程的时候了解到的，那么下面就深入的讲讲这个程序。这个游戏代码量不大，由主程序在 main.c 这个文件里，游戏程序在 game.c 这个文件里，以及函数、头文和声明程序 game.h 这个程序组成。c如果要实现标记等功能，还会麻烦很多。\n游戏本体代码\nmain.c文件\n#include &quot;game.h&quot;void menu()&#123;    printf(&quot;1. play\\n&quot;);    printf(&quot;0. exit\\n&quot;);&#125;void game()&#123;    char mine[ROWS][COLS] = &#123;0&#125;;   //存放布置好的雷的信息    char show[ROWS][COLS] = &#123;0&#125;;   //存放排查出的雷的信息    //初始化数组的内容为指定的内容    //mine数组在没有初始化的时候，都是&#x27;0&#x27;    Initboard(mine, ROWS, COLS, &#x27;0&#x27;);    //show数组在没有初始化的时候，都是&#x27;*&#x27;    Initboard(show, ROWS, COLS, &#x27;*&#x27;);    //布置雷    Setmine(mine, ROW, COL);    //Displayboard(mine, ROW, COL);    Displayboard(show, ROW, COL);    //排查雷    Findmine(mine, show, ROW, COL);&#125;int main()&#123;    int input = 0;    srand ((unsigned int)time(NULL));    do     &#123;        menu();        printf(&quot;请选择:&gt;&quot;);        scanf(&quot;%d&quot;, &amp;input);        switch(input)        &#123;        case 1:            game();            break;        case 0:            printf(&quot;退出游戏\\n&quot;);            break;        default:            printf(&quot;选择错误，重新选择:&gt;&quot;);            break;        &#125;    &#125; while(input);    return 0;&#125;\ngame.c文件\n#include &quot;game.h&quot;void Initboard(char board[ROWS][COLS], int rows, int cols, char a)&#123;    int i = 0;    int j = 0;    for (i = 0; i &lt; rows; i ++)    &#123;        for (j = 0; j &lt; cols; j ++)        &#123;            board[i][j] = a;        &#125;    &#125;&#125;void Displayboard(char board[ROWS][COLS], int row, int col)&#123;    int i = 0;    int j = 0;    printf(&quot;······ 扫雷游戏 ······\\n&quot;);    for (j = 0; j &lt;= col; j ++)    &#123;        printf(&quot;%d &quot;, j);    &#125;    printf(&quot;\\n&quot;);    for (i = 1; i &lt;= row; i ++)    &#123;        printf(&quot;%d &quot;, i);        for (j = 1; j &lt;= col; j ++)        &#123;            printf(&quot;%c &quot;, board[i][j]);        &#125;        printf(&quot;\\n&quot;);    &#125;&#125;void Setmine(char board[ROWS][COLS], int row, int col)&#123;    int count = EASY_COUNT;    while (count)    &#123;        int x = rand() % row + 1;        int y = rand() % col + 1;        if (board[x][y] == &#x27;0&#x27;)        &#123;            board[x][y] = &#x27;1&#x27;;            count --;        &#125;    &#125;&#125;int get_mine_count(char mine[ROWS][COLS], int x, int y)&#123;    return (mine[x - 1][y - 1] +    mine[x - 1][y] +    mine[x - 1][y + 1] +    mine[x][y - 1] +    mine[x][y + 1] +    mine[x + 1][y - 1] +    mine[x + 1][y - 1] +    mine[x + 1][y] - 8 * &#x27;0&#x27;);    &#125;void Findmine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col)&#123;    int x = 0;    int y = 0;    int win = 0;    while (win &lt; row * col - EASY_COUNT)    &#123;        printf(&quot;请输入你要排查的坐标:&gt;&quot;);        scanf(&quot;%d %d&quot;, &amp;x, &amp;y);        if (x &gt;= 1 &amp;&amp; x &lt;= row &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= col)        &#123;            if (show[x][y] != &#x27;*&#x27;)            &#123;                printf(&quot;该坐标已被排查，不能重新排查\\n&quot;);            &#125;            else            &#123;                if (mine[x][y] == &#x27;1&#x27;)                &#123;                    printf(&quot;很遗憾,你被炸死了\\n&quot;);                    Displayboard(mine, ROW, COL);                    break;                &#125;                else                &#123;                    win ++;                    int count = get_mine_count(mine, x + 1, y + 1);                    show[x][y] = count + &#x27;0&#x27;;                    Displayboard(show, ROW, COL);                &#125;             &#125;        &#125;        else        &#123;            printf(&quot;您输入的坐标错误,重新输入:&gt;&quot;);        &#125;    &#125;    if (win == row * col - EASY_COUNT)    &#123;        printf(&quot;恭喜你排雷成功！\\n&quot;);        Displayboard(mine, ROW, COL);    &#125;&#125;\ngame.h文件\n#include &lt;stdio.h&gt;#include &lt;time.h&gt;#include &lt;stdlib.h&gt;#define ROW 9#define COL 9#define ROWS 9 + 2#define COLS 9 + 2#define EASY_COUNT 10void Initboard(char board[ROWS][COLS], int rows, int cols, char a);void Displayboard(char board[ROWS][COLS], int row, int col);void Setmine(char board[ROWS][COLS], int row, int col);void Findmine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col);\n深入讲解这个游戏\n为了让大家更好的看到这个游戏的所有代码，我把这个游戏的代码复制在了上面，有需要的小伙伴们可以复制到自己创建的文件夹里先玩一玩。现在我们来深入讲讲这个程序。\nmain.c文件分析\nmain主调函数\n我们先来看 main 这个主函数，这个主函数里面包含了一个 srand 函数，而这个 srand 函数中又包含了一个 time 函数，由于 time 函数函数的原型中是传入一个指针，但是由于欧我们用这个time函数是为了生成随机数，所以传入一个空指针就可以了。 time函数原型如下图所示：\ntime_t time(time_t *timer);\n随后，是使用了一个 do while 循环，使用 do while 循环的目的就是让程序先做，在执行判断程序，当输入的值为0的时候，整个程序就不会再继续。如你所见， 用 main 主函数还调用了一个叫做 menu 的函数，大家想必是看一眼就知道这个函数是干什么用的，就是打印一个菜单让用户选择。然后在执行 switch case 语句，用户选择 1 的时候，就调用 game 这个函数随后玩游戏，用户选择 0 的时候，就退出游戏。\ngame函数\n由名字就可以知道，这个 game 函数中放着这个游戏中最最最重要的部分，我先简单介绍一下 game 函数中的各个参数是干什么的。\n首先就是两个二维数组，其中 mine 这个数组是用来存放布置好雷的信息，而 show 这个数组则是用来存放排查出来雷的信息的。那么很多人就会有疑惑，为什么要用两个数组呢？因为我们这个程序中的数组中存放的值是要展现给用户的，如果只有一个数组，那总不可以既存放布置好雷的信息，又存放排查出雷的信息吧，如果全部都存放了，那岂不是就可以看到雷在哪里布置了吗？所以要创建两个二维数组。\n介绍完了要用到的数组，接下来就来介绍一下这个 geme 函数中调用的函数，我们在这里只是简单的介绍一下这些函数的作用，主要的思考思路在下面会讲。\n\nInitboard() 这个函数是用来初始化数组的，我们便于区分，就把排查雷的数组 mine 里面的所有值初始化成为 字符零 即（‘0’），注意：是 字符零 而不是数字 0，把 show 这个数组里的值转化成为 ‘*’ 为什么呢，在深入讲这个函数的时候会讲。\nSetmine() 这个函数就是布置雷，布置在数组 mine 中\nDisplayboard() 这个函数很简单，就是打印这个数组的值按照 9 x 9 的这种形式，但是里面还有很多小细节，下面会讲到。\nFindmine() 这个函数就是排查雷，细节也很多，下面讲。\n\ngame.h 文件分析\n函数声明\n首先，最前面的三个就是使用的库函数的声明，下面的就是之前前讲过的函数的声明，由于之前讲过了，这里就不做过多说明了。\n不变量的分析\nROW 和 COL 这两个不变量，这两个不变量的作用就是创建数组的时候用到的。\n那么要知道为什么要创建 ROWS 和 COLS 的时候我们就必须要知道扫雷游戏的判定机制。\n\n我们知道，扫雷游戏在玩的过程中其实就是不断的排雷排雷，我们每按下一个空白部分进行排雷的时候，如果空白部分正好是雷，那么游戏就结束了，如果空白部分不是雷，他就会提醒周围有几个雷，如下图所示：\n\n其实啊，这个数字提示的就是周围这一圈雷的个数，也就是一个九宫格中除了中间你点的部分，也就是他周围八个空格中有多少个雷。所以，我们仔细想想就会发现我们创建 9 x 9 的数组是不够的，如果创建了 9 x 9 的数组，那么就会造成越界访问的现象，所以因该创建 11 x 11 的数组，详细图解如下：\n\n好的，这样子每行没列就都是11，所以我们在排查雷的时候就不需要考虑数组越界访问这种情况了。只需要在打印扫雷界面的时候展示 9 x 9 的数组就可以了。\n接下来就是 EASY_COUNT 这个不变量，这个不变量的作用就表示雷的个数。\ngame.c文件分析\nInitboard()函数\n这个函数的目的就是把二维数组的各个值初始化，我们在前面main文件中的注释中已经提到了，把布置雷的数组全部初始化为 ‘0’ ，再给展示给用户的部分全部初始化为 ‘*’ ，由于我们想要用一个函数就可以把两个数组全部初始化，这样子就可以通过多传入一个参数的方式来解决这个问题，所以我们使用了 a 这个形参来接收传过来的字符。\nDisplayboard()函数\n这个函数就是为了打印扫雷游戏的界面展现给用户，也算是比较重要，我先来给大家展示一下调用玩这个函数之后屏幕上打印的东西，这样便于分析。\n\n我们发现除了中间的 9 x 9 的 * 之后外围还有数字，这些数字的目的也就是为了帮助玩家更好的输入坐标。\n现在，我们来深入的介绍这个程序，首先这个程序中有三个 for 循环，我们来逐个介绍，首先第一个 for 循环，这个 for 循环的作用就是打印上方的坐标提示的，如下图所示（我画线部分）：\n\n好的，现在我们来介绍第二个 for 循环以及嵌套在他里面的 for 循环，首先我们需要知道 i 的值在二维数组中表示的是行的个数， j 的值在二维数组中表示的是列的个数。\n也就是说，i，j 都从1开始取，通过 &lt;= 就可以打印出 9 x 9 排列的。而 printf(&quot;%d &quot;, i); 就是为了打印每一行的值，i从1开始取，这样子就正好在外围表示出了整个扫雷游戏内所有位置的正确坐标信息。\nSetmine()函数\n这个函数就是一个布置雷的函数，思路其实很简单，就是随机在数组的任意位置布置随机的雷，我们用到了 rand() 这个函数来生成随机值，通过将其生成的随机值求模运算上一个 row 或者 col （这两个数的值都为9，传入的值是不变量ROW和COL的值）因为任意的数取模9的话最大的余数就是8，所以加上1，这样就可以取到所有坐标的数，以便于随机排雷。随后就是这个 if 语句，这个语句其实就是判断二维数组中的位置上是不是布置好雷了，这样就不怕重复布置雷，随后每布置完一个雷 count 就减减，这样子不布置得雷的数量就越来越少，这样就不会死循环，当count的值为零的时候，就跳出了 while 循环。\nFindmine()函数和get_mine_count()函数\n由于 get_mine_count()函数 是被 Findmine()函数 调用的，所以这两个函数我放在一起介绍。\n这个函数实际就是与用户进行交互的函数，也就是用户排查雷的函数，也是判断用户排查的位置是否有雷的函数，我们的 EASY_COUNT 这个不变量就是在这里被使用的。现在我们来详细分析这个函数。\n首先，就是提示让用户输入的坐标，接着我们先来看第一个 if 语句，这条 if 语句里面的判定条件 x &gt;= 1 &amp;&amp; x &lt;= row &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= col 其实就是判断用户输入的坐标是否越界访问，对接着最后方的 else 语句，提示用户输入错误要重新输入。\n下面我们来看嵌套在第一个 if 语句中的第二个 if 语句，我们规定了 ‘*’ 的时候是没有排查过的，这条语句其实就是判断用户输入的坐标是否已经被排查过了。\n再来看下面的 else 语句中包含的 if 语句，这条语句很明显，就是判断用户是否踩到了雷，如果踩到了雷，那么就提示用户踩到了雷，随后就跳出程序，游戏结束。\n而与之对应的 else 语句的内容就比较丰富了，我们逐个来讲解。首先，是这个 win ，这个 win 的作用就是用来计数，每排掉一次雷就执行一次 win++ 也就是 win 的值加上一，在最后一个 if 语句中会用到win的值。\n随后就是 get_mine_count() 这个函数了，我使用了图解的方式来给大家展示。\n\n我用数学的方式来讲，可能会更好理解一些，我们设九宫格中点的坐标为 x,y 这样我们就可以很轻松的推断出其他坐标的位置，我们知道扫雷会在你排完雷之后在周围显示出以你排查的坐标为原点的周围的八个坐标内有雷的个数。所以 Findmine() 调用这个函数实则就是为了计算周围一圈有多少个雷，然后返回到 count 里，count 加上字符零时则就是把 count 变成字符型展现在屏幕上，和 ‘*’ 、 ‘1’ 一样。\n最后这个 if 语句就是判断 win 是否为10，如果是10那么游戏就结束了。\n总结\n现在，我已经把这个游戏全部仔细分析完了，希望对大家的C语言的学习有一些帮助，如果有什么问题请及时给我反馈，我会好好修改的。\n","categories":["C"],"tags":["代码","小项目","练手程序","C"]},{"title":"我的第一篇博客文章","url":"/2026/02/03/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","content":"个人简述\n大家好，我是Gin。我是一个来自浙江的职高生，专业：机电技术应用，由于我小学的时候没有学习编程，初中的时候又没有电脑，当时想要学习python但是电脑是真的太卡了，所以学编程的事情就算是放了下来，就是在初三中考完的暑假里，我拥有了我自己的电脑，但是我的电脑是mac。当时刚开始学习C语言，我什么也不懂，看着网上不知名的课程在那边瞎写代码，然后就是遇到一大堆报错，我用vscode输出“Hello world！“都用了好几个小时的时间。在学C语言的时候，有听说可以通过调试来学习C语言可以理解的更加深入，结果我真的是啥也不懂配置调试文件也弄了好久。我刚开始的时候不知道调试文件是每一个项目都要重新配置的，所以就一直没有用调试来学习。\n我是学习到C语言将近到一半的时候才开始会配置调试文件的，AI非常好用我就问AI，AI不会就看视频来学习，反正调试就是学会了。其实我本来不是职高生，我们浙江这边有一个政策叫做普职融通班（就是普高的学生转到职高，职高的学生转到普高）我所在的普高比较烂，只有一个理科班，而且我高一第一学期学习非常不认真，可想而知我的成绩是非常差劲的，所以我选择了普职融通这条路，便成为了职高生。\n反正高一下学期就去职高了，那普高的知识就不学了呗。所以我上课要么看课外书，要么写代码（当时看C Primer Plus后面的编程题目在纸上写代码）。\n今天终于是把这个博客搭建完成了，我真的真的非常开心啊！在今后的日子里，我也会继续更新这个网站，继续完善这个网站的整体功能。我也会继续为大家做很有意思很带劲的内容，欢迎关注我的B站账号、csdn博客、github等等。感谢你们！\n#include &lt;stdio.h&gt;int main()&#123;    printf(&quot;Hello everyone I&#x27;m Gin&quot;);    return 0;&#125;\n","categories":["杂七杂八"]}]